//TODO: Fix sempahores - sync must be done for the ring buffer, where two messages are sent it will fail

#include <stdbool.h>
#include <stdint.h>
#include "slip.h"

#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(slip, LOG_LEVEL_INF);

int init_slip_buffer(struct slipBuffer* slip_buf, uint8_t* buf, int size) {
	if (NULL == slip_buf || NULL == buf) {
		LOG_ERR("Invalid slip buffer or buffer");
		return -1;
	}
	
	slip_buf->last = SLIP_END;
	ring_buf_init(&(slip_buf->ringBuf), size, buf);
	
	int err = k_sem_init(&slip_buf->ring_buffer_sem, 1, 1);
	if (err) {
		LOG_ERR("Failed to initialize ring buffer slip semaphore");
		return -1;
	}

	err = k_sem_init(&slip_buf->packet_ready_sem, 0, SLIP_READ_PACKETS_MAX_QTY);
	if (err) {
		LOG_ERR("Failed to initialize packet ready slip semaphore");
		return -1;
	}

	return 0;
}

// Takes a slip encoded byte from the UART and puts it to the buffer
void slip_uart_putc(struct slipBuffer* slip_buf, char c) {
	
	if (0 != k_sem_take(&slip_buf->ring_buffer_sem, K_MSEC(50))) {
		LOG_DBG("Ring buffer sempahore is not available");
		return;
	}
	LOG_DBG("Ring buffer sempahore taken, %d", k_sem_count_get(&slip_buf->ring_buffer_sem));

	int written = ring_buf_put(&(slip_buf->ringBuf), &c, 1);
	k_sem_give(&slip_buf->ring_buffer_sem);
	LOG_DBG("Ring buffer sempahore given, %d", k_sem_count_get(&slip_buf->ring_buffer_sem));

	if (written != 1) {
		LOG_ERR("Failed to write to slip ring buffer");
		return;
	}

	if (c == SLIP_END && slip_buf->last != SLIP_END) {
		// Got END for non empty packet
		// slip_buf->packetCnt++;
		k_sem_give(&slip_buf->packet_ready_sem);
		LOG_DBG("Give sem, %d", k_sem_count_get(&slip_buf->packet_ready_sem));
	}
	slip_buf->last = c;
}

/* SEND_PACKET: sends a packet of length "len", starting at
 * location "p".
 */
void slip_send_packet(uint8_t *p, int len, void (*send_char)(char c)) {

	/* send an initial END character to flush out any data that may
	 * have accumulated in the receiver due to line noise
	 */
	send_char(SLIP_END);

	slip_encode(p, len, send_char);

	/* tell the receiver that we're done sending the packet
	 */
	send_char(SLIP_END);
}

void slip_encode(const uint8_t* p, int len, void (* send_char)(char c)) {
	/* for each byte in the packet, send the appropriate character
	 * sequence
	 */
	while (len--) {
		switch (*p) {
		/* if it's the same code as an END character, we send a
		 * special two character code so as not to make the
		 * receiver think we sent an END
		 */
		case SLIP_END:
			send_char(SLIP_ESC);
			send_char(SLIP_ESC_END);
			break;

			/* if it's the same code as an ESC character,
			 * we send a special two character code so as not
			 * to make the receiver think we sent an ESC
			 */
		case SLIP_ESC:
			send_char(SLIP_ESC);
			send_char(SLIP_ESC_ESC);
			break;
			/* otherwise, we just send the character
			 */
		default:
			send_char(*p);
		}
		p++;
	}
}

/* RECV_PACKET: reads a packet from buf into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int slip_read_packet(struct slipBuffer* slip_buf, uint8_t *p, int len) {
	char c;
	int received = 0;

	memset(p, 0, len);

	/* sit in a loop reading bytes until we put together
	 * a whole packet.
	 * Make sure not to copy them into the packet if we
	 * run out of room.
	 */
	while (1) {
		/* get a character to process
		 */
		if (ring_buf_is_empty(&(slip_buf->ringBuf))) {
			if (k_sem_count_get(&slip_buf->packet_ready_sem) != 0) {
				LOG_ERR("Ring buffer is empty but packet count is not zero");
				// k_sem_give(&slip_buf->sem_ring_buffer);
				return -1;
			}
			// k_sem_give(&slip_buf->sem_ring_buffer);
			return received;
		}

		if (ring_buf_space_get(&(slip_buf->ringBuf)) == 0) {
			LOG_ERR("Ring buffer is full");
			// k_sem_give(&slip_buf->sem_ring_buffer);
			return -1;
		}

		if (0 != k_sem_take(&slip_buf->ring_buffer_sem, K_MSEC(50))) {
			LOG_DBG("Ring buffer sempahore is not available");
			return -1;
		}

		uint32_t got_byte_count = ring_buf_get(&(slip_buf->ringBuf), (uint8_t*)&c, 1);
		if (got_byte_count != 1) {
			LOG_ERR("Failed to read from slip ring buffer");
			k_sem_give(&slip_buf->ring_buffer_sem);
			LOG_DBG("Give ring buffer sem, %d", k_sem_count_get(&slip_buf->ring_buffer_sem));
			return -1;
		}
		LOG_DBG("Give ring buffer sem, %d", k_sem_count_get(&slip_buf->ring_buffer_sem));
		k_sem_give(&slip_buf->ring_buffer_sem);

		/* handle bytestuffing if necessary
		 */
		switch (c) {

			/* if it's an END character then we're done with
			* the packet
			*/
			case SLIP_END:
				/* a minor optimization: if there is no
				* data in the packet, ignore it. This is
				* meant to avoid bothering IP with all
				* the empty packets generated by the
				* duplicate END characters which are in
				* turn sent to try to detect line noise.
				*/
				if (received) {
					k_sem_take(&slip_buf->packet_ready_sem, K_NO_WAIT);
					LOG_DBG("Take sem, %d", k_sem_count_get(&slip_buf->packet_ready_sem));
					return received;
				}
				else {
					break;
				}

				/* if it's the same code as an ESC character, wait
				* and get another character and then figure out
				* what to store in the packet based on that.
				*/
			case SLIP_ESC:
				if (ring_buf_is_empty(&(slip_buf->ringBuf))) {
					if (k_sem_count_get(&slip_buf->packet_ready_sem) != 0) {
						LOG_ERR("Ring buffer is empty but packet count is not zero");
					return -1;
				}
					return received;
				}
				if (ring_buf_space_get(&(slip_buf->ringBuf)) == 0) {
					LOG_ERR("Ring buffer is full");
					return -1;
				}
				
				if (0 != k_sem_take(&slip_buf->ring_buffer_sem, K_MSEC(50))) {
					LOG_DBG("Ring buffer sempahore is not available");
					return -1;
				}

				got_byte_count = ring_buf_get(&(slip_buf->ringBuf), (uint8_t*)&c, 1);
				if (got_byte_count != 1) {
					LOG_ERR("Failed to read from slip ring buffer");
					k_sem_give(&slip_buf->ring_buffer_sem);
					LOG_DBG("Give ring buffer sem, %d", k_sem_count_get(&slip_buf->ring_buffer_sem));
					return -1;
				}
				LOG_DBG("Give ring buffer sem, %d", k_sem_count_get(&slip_buf->ring_buffer_sem));
				k_sem_give(&slip_buf->ring_buffer_sem);

				/* if "c" is not one of these two, then we
				* have a protocol violation.  The best bet
				* seems to be to leave the byte alone and
				* just stuff it into the packet
				*/
				switch (c) {
				case SLIP_ESC_END:
					c = SLIP_END;
					break;
				case SLIP_ESC_ESC:
					c = SLIP_ESC;
					break;
				}
				// Store the character
				if (received < len) {
					p[received++] = c;
				}
				break;
			default:
				// Store the character
				if (received < len) {
					p[received++] = c;
				}
		}
	}

	// k_sem_give(&slip_buf->sem_ring_buffer);
}
