//TODO: Fix sempahores - sync must be done for the ring buffer, where two messages are sent it will fail

#include <stdbool.h>
#include <stdint.h>
#include "slip.h"

#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(slip, LOG_LEVEL_DBG);

void init_slip_buffer(struct slipBuffer* slip_buf, uint8_t* buf, int size, struct k_poll_signal* signal) {
	if (NULL == slip_buf) {
		LOG_ERR("Slip buffer is NULL");
		return;
	}
	
	slip_buf->packetCnt = 0;
	slip_buf->last = SLIP_END;
	ring_buf_init(&(slip_buf->ringBuf), size, buf);
	
	int err = k_sem_init(&slip_buf->sem_ring_buffer, 1, 1);
	if (err) {
		LOG_ERR("Failed to initialize slip semaphore");
	}

	if (NULL == signal) {
		LOG_ERR("Signal is NULL");
		return;
	}
	slip_buf->signal_packet_ready = signal;
}

// Takes a slip encoded byte from the UART and puts it to the buffer
void slip_uart_putc(struct slipBuffer* slip_buf, char c) {
	
	// if (0 != k_sem_take(&slip_buf->sem_ring_buffer, K_MSEC(50))) {
		// return;
	// }

	int written = ring_buf_put(&(slip_buf->ringBuf), &c, 1);
	// k_sem_give(&slip_buf->sem_ring_buffer);

	if (written != 1) {
		LOG_ERR("Failed to write to slip ring buffer");
		return;
	}

	if (c == SLIP_END && slip_buf->last != SLIP_END) {
		// Got END for non empty packet
		slip_buf->packetCnt++;
		k_poll_signal_raise(slip_buf->signal_packet_ready, 0);
	}
	slip_buf->last = c;
}

/* SEND_PACKET: sends a packet of length "len", starting at
 * location "p".
 */
void slip_send_packet(uint8_t *p, int len, void (*send_char)(char c)) {

	/* send an initial END character to flush out any data that may
	 * have accumulated in the receiver due to line noise
	 */
	send_char(SLIP_END);

	slip_encode(p, len, send_char);

	/* tell the receiver that we're done sending the packet
	 */
	send_char(SLIP_END);
}

void slip_encode(const uint8_t* p, int len, void (* send_char)(char c)) {
	/* for each byte in the packet, send the appropriate character
	 * sequence
	 */
	while (len--) {
		switch (*p) {
		/* if it's the same code as an END character, we send a
		 * special two character code so as not to make the
		 * receiver think we sent an END
		 */
		case SLIP_END:
			send_char(SLIP_ESC);
			send_char(SLIP_ESC_END);
			break;

			/* if it's the same code as an ESC character,
			 * we send a special two character code so as not
			 * to make the receiver think we sent an ESC
			 */
		case SLIP_ESC:
			send_char(SLIP_ESC);
			send_char(SLIP_ESC_ESC);
			break;
			/* otherwise, we just send the character
			 */
		default:
			send_char(*p);
		}
		p++;
	}
}

/* RECV_PACKET: reads a packet from buf into the buffer located at "p".
 *      If more than len bytes are received, the packet will
 *      be truncated.
 *      Returns the number of bytes stored in the buffer.
 */
int slip_read_packet(struct slipBuffer* slip_buf, uint8_t *p, int len) {
	char c;
	int received = 0;

	if (slip_buf->packetCnt == 0) {
		LOG_DBG("105");
		return 0;
	}

	memset(p, 0, len);

	/* sit in a loop reading bytes until we put together
	 * a whole packet.
	 * Make sure not to copy them into the packet if we
	 * run out of room.
	 */
	while (1) {
		/* get a character to process
		 */
		// if (0 != k_sem_take(&slip_buf->sem_ring_buffer, K_MSEC(50))) {
		// 	LOG_DBG("104");
		// 	return -1;
		// }

		if (ring_buf_is_empty(&(slip_buf->ringBuf))) {
			if (slip_buf->packetCnt != 0) {
				LOG_ERR("Ring buffer is empty but packet count is not zero");
				// k_sem_give(&slip_buf->sem_ring_buffer);
				return -1;
			}
			LOG_DBG("101");
			// k_sem_give(&slip_buf->sem_ring_buffer);
			return received;
		}

		if (ring_buf_space_get(&(slip_buf->ringBuf)) == 0) {
			LOG_ERR("Ring buffer is full");
			// k_sem_give(&slip_buf->sem_ring_buffer);
			return -1;
		}

		ring_buf_get(&(slip_buf->ringBuf), (uint8_t*)&c, 1);
		
		/* handle bytestuffing if necessary
		 */
		switch (c) {

			/* if it's an END character then we're done with
			* the packet
			*/
			case SLIP_END:
				/* a minor optimization: if there is no
				* data in the packet, ignore it. This is
				* meant to avoid bothering IP with all
				* the empty packets generated by the
				* duplicate END characters which are in
				* turn sent to try to detect line noise.
				*/
				if (received) {
					slip_buf->packetCnt--;
					LOG_DBG("102");
					return received;
				}
				else {
					break;
				}

				/* if it's the same code as an ESC character, wait
				* and get another character and then figure out
				* what to store in the packet based on that.
				*/
			case SLIP_ESC:
				if (ring_buf_is_empty(&(slip_buf->ringBuf))) {
					if (slip_buf->packetCnt != 0) {
						LOG_ERR("Ring buffer is empty but packet count is not zero");
					return -1;
				}
					LOG_DBG("103");
					return received;
				}
				if (ring_buf_space_get(&(slip_buf->ringBuf)) == 0) {
					LOG_ERR("Ring buffer is full");
					return -1;
				}
				ring_buf_get(&(slip_buf->ringBuf), (uint8_t*)&c, 1);

				/* if "c" is not one of these two, then we
				* have a protocol violation.  The best bet
				* seems to be to leave the byte alone and
				* just stuff it into the packet
				*/
				switch (c) {
				case SLIP_ESC_END:
					c = SLIP_END;
					break;
				case SLIP_ESC_ESC:
					c = SLIP_ESC;
					break;
				}
				// Store the character
				if (received < len) {
					p[received++] = c;
				}
				break;
			default:
				// Store the character
				if (received < len) {
					p[received++] = c;
				}
		}
	}

	// k_sem_give(&slip_buf->sem_ring_buffer);
}
